import * as React from 'react';
import { useParams } from 'react-router-dom';
import { useWatchLater } from '../contexts/WatchLaterContext';
import { Video as CoreVideo } from '../src/types/core';

// Define interfaces for our data structures
interface Channel {
  id: string;
  name: string;
  avatarUrl: string;
  subscribers?: number;
  isSubscribed?: boolean;
  isVerified?: boolean;
}

interface Comment {
  id: string;
  author: string;
  avatar: string;
  text: string;
  timestamp: string;
  likes: number;
  dislikes: number;
  isLiked?: boolean;
  isDisliked?: boolean;
  replies?: Comment[];
  isReplying?: boolean;
  isEditing?: boolean;
}

// Using CoreVideo type directly instead of extending to avoid conflicts
type Video = CoreVideo & {
  captions?: Array<{
    id: string;
    language: { name: string; code: string };
    label: string;
    url: string;
    isAutoGenerated?: boolean;
  }>;
  likes?: number;
  dislikes?: number;
  tags?: string[];
  visibility?: string;
  commentCount?: number;
  channelName?: string;
  channelAvatarUrl?: string;
  category?: string;
  uploadedAt?: string;
  videoUrl: string;
  duration: string;
  channelId?: string;
  status?: string;
  isLiked?: boolean;
  isDisliked?: boolean;
  isSubscribed?: boolean;
  isSavedToAnyList?: boolean;
  createdAt?: string;
  updatedAt?: string;
  channel?: Channel;
};

interface RefactoredWatchPageProps {
  video?: Video;
  error?: string | null;
  loading?: boolean;
  handleLike?: (videoId: string) => void;
  handleSubscribe?: (channelId: string) => void;
  handleShare?: (videoId: string) => void;
  handleDislike?: (videoId: string) => void;
  handleAddToWatchLater?: (video: Video) => void;
  handleSummarizeDescription?: (videoId: string) => Promise<string>;
  handleToggleDescription?: () => void;
  handleMainCommentSubmitCallback?: (commentText: string) => void;
  handleReplySubmit?: (commentId: string, replyText: string) => void;
  handleEditSave?: (commentId: string, newText: string) => void;
  handleDeleteComment?: (commentId: string) => void;
  toggleLikeDislikeForCommentOrReply?: (commentId: string, action: 'like' | 'dislike') => void;
  setReplyingToCommentId?: (id: string | null) => void;
  setCurrentReplyText?: (text: string) => void;
  setEditingComment?: (comment: { id: string; text: string } | null) => void;
  setActiveCommentMenu?: (id: string | null) => void;
  setExpandedReplies?: (ids: string[]) => void;
  closeSaveModal?: () => void;
  handleSaveToPlaylist?: (playlistId: string) => Promise<void>;
  handleCreatePlaylist?: (name: string, isPrivate: boolean) => Promise<void>;
}

// Mock data for when the video is loading or not found
const mockVideo: Video = {
  id: 'mock-video-id',
  title: 'Loading video...',
  description: 'Video description will appear here',
  duration: '0:00',
  thumbnailUrl: '',
  videoUrl: '',
  viewCount: 0,  // Changed from string to number to match type
  views: 0,
  likes: 0,
  dislikes: 0,
  commentCount: 0,
  category: 'Education',
  visibility: 'public',
  tags: [],
  captions: [],
  uploadedAt: new Date().toISOString(),
  channelId: 'mock-channel-id',
  channelName: 'Loading channel...',
  channelAvatarUrl: '',
  status: 'published',
  isLiked: false,
  isDisliked: false,
  isSubscribed: false,
  isSavedToAnyList: false,
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
  channel: {
    id: 'mock-channel-id',
    name: 'Loading channel...',
    avatarUrl: '',
    subscribers: 0,
    isSubscribed: false,
    isVerified: false
  }
};

const RefactoredWatchPage: React.FC<RefactoredWatchPageProps> = ({
  video: propVideo,
  error: propError,
  loading: propLoading,
  handleLike: propHandleLike = () => {},
  handleSubscribe: propHandleSubscribe = () => {},
  handleShare = () => {},
  handleDislike = () => {},
  handleAddToWatchLater: propHandleAddToWatchLater = () => {},
  handleSummarizeDescription = async () => '',
  handleToggleDescription = () => {},
  handleMainCommentSubmitCallback = () => {},
  handleReplySubmit = () => {},
  handleEditSave = () => {},
  handleDeleteComment = () => {},
  toggleLikeDislikeForCommentOrReply = () => {},
  setReplyingToCommentId: propSetReplyingToCommentId = () => {},
  setCurrentReplyText: propSetCurrentReplyText = () => {},
  setEditingComment: propSetEditingComment = () => {},
  setActiveCommentMenu: propSetActiveCommentMenu = () => {},
  setExpandedReplies: propSetExpandedReplies = () => {},
  closeSaveModal: propCloseSaveModal = () => {},
  handleSaveToPlaylist: propHandleSaveToPlaylist = async () => {},
  handleCreatePlaylist: propHandleCreatePlaylist = async () => {}
}) => {
  const { useState, useCallback } = React;
  
  // Use provided video or fallback to mock video
  const video = propVideo || mockVideo;
  const error = propError || null;
  const loading = propLoading || false;
  
  // Local state
  const [isLiked, setIsLiked] = useState(video.isLiked ?? false);
  const [isDisliked, setIsDisliked] = useState(video.isDisliked ?? false);
  const [isSubscribed, setIsSubscribed] = useState(video.isSubscribed ?? false);
  const [isSaved, setIsSaved] = useState(video.isSavedToAnyList ?? false);
  const [isSaveModalOpen, setIsSaveModalOpen] = useState(false);
  const [commentSortOrder, setCommentSortOrder] = useState<'top' | 'newest'>('top');
  const [isDescriptionExpanded, setIsDescriptionExpanded] = useState(false);
  const [isSummaryLoading, setIsSummaryLoading] = useState(false);
  const [summary, setSummary] = useState('');
  const [summaryError, setSummaryError] = useState<string | null>(null);
  const [actionError, setActionError] = useState<string | null>(null);
  const [comments, setComments] = useState<Comment[]>([]);
  const [replyingToCommentId, setReplyingToCommentId] = useState<string | null>(null);
  const [currentReplyText, setCurrentReplyText] = useState('');
  const [editingComment, setEditingComment] = useState<{ id: string; text: string } | null>(null);
  const [activeCommentMenu, setActiveCommentMenu] = useState<string | null>(null);
  const [expandedReplies, setExpandedReplies] = useState<string[]>([]);
  const [playlists, setPlaylists] = useState<Array<{ id: string; name: string; isPrivate: boolean }>>([]);
  const [isLoadingPlaylists, setIsLoadingPlaylists] = useState(false);
  const [playlistsError, setPlaylistsError] = useState<string | null>(null);
  
  // State management
  const [isLiked, setIsLiked] = useState(video.isLiked ?? false);
  const [isDisliked, setIsDisliked] = useState(video.isDisliked ?? false);
  const [isSubscribed, setIsSubscribed] = useState(video.isSubscribed ?? false);
  const [isSaved, setIsSaved] = useState(video.isSavedToAnyList ?? false);
  const [isSaveModalOpen, setIsSaveModalOpen] = useState(false);
  const [commentSortOrder, setCommentSortOrder] = useState<'top' | 'newest'>('top');
  const [isDescriptionExpanded, setIsDescriptionExpanded] = useState(false);
  const [isSummaryLoading, setIsSummaryLoading] = useState(false);
  const [summary, setSummary] = useState('');
  const [summaryError, setSummaryError] = useState<string | null>(null);
  const [actionError, setActionError] = useState<string | null>(null);
  const [comments, setComments] = useState<Comment[]>([]);
  const [replyingToCommentId, setReplyingToCommentId] = useState<string | null>(null);
  const [currentReplyText, setCurrentReplyText] = useState('');
  const [editingComment, setEditingComment] = useState<{ id: string; text: string } | null>(null);
  const [activeCommentMenu, setActiveCommentMenu] = useState<string | null>(null);
  const [expandedReplies, setExpandedReplies] = useState<string[]>([]);
  const [playlists, setPlaylists] = useState<Array<{ id: string; name: string; isPrivate: boolean }>>([]);
  const [isLoadingPlaylists, setIsLoadingPlaylists] = useState(false);
  const [playlistsError, setPlaylistsError] = useState<string | null>(null);

  // Use provided video or fallback to mock video
  const video = propVideo || mockVideo;
  const error = propError || null;
  const loading = propLoading || false;
  
  // Get watch later context
  const { addToWatchLater } = useWatchLater();
  
  // Handle add to watch later
  const handleAddToWatchLater = useCallback(async () => {
    if (!video?.id) return;
    
    try {
      const videoToAdd: Video = {
        id: video.id,
        title: video.title || 'Untitled Video',
        description: video.description || '',
        duration: video.duration || '0:00',
        thumbnailUrl: video.thumbnailUrl || '',
        videoUrl: video.videoUrl || '',
        viewCount: video.viewCount || 0,
        channelName: video.channelName || 'Unknown Channel',
        channelAvatarUrl: video.channelAvatarUrl || '',
        uploadedAt: video.uploadedAt || new Date().toISOString(),
        channelId: video.channelId || 'unknown-channel',
        status: video.status || 'public',
        ...video
      };
      
      if (propHandleAddToWatchLater) {
        await propHandleAddToWatchLater(videoToAdd);
      } else if (addToWatchLater) {
        await addToWatchLater(videoToAdd);
      }
    } catch (err) {
      console.error('Error adding to watch later:', err);
      // Handle error appropriately
    }
  }, [video, propHandleAddToWatchLater, addToWatchLater]);
  
  // Handle save to playlist
  const handleSaveToPlaylist = useCallback(async (playlistId: string) => {
    try {
      if (propHandleSaveToPlaylist) {
        await propHandleSaveToPlaylist(playlistId);
      }
      setIsSaveModalOpen(false);
    } catch (error) {
      console.error('Error saving to playlist:', error);
      // Handle error appropriately
    }
  }, [propHandleSaveToPlaylist]);
  
  // Handle create playlist
  const handleCreatePlaylist = useCallback(async (name: string, isPrivate: boolean) => {
    try {
      if (propHandleCreatePlaylist) {
        await propHandleCreatePlaylist(name, isPrivate);
      }
    } catch (error) {
      console.error('Error creating playlist:', error);
      // Handle error appropriately
    }
  }, [propHandleCreatePlaylist]);
  
  // Handle comment submission
  const handleMainCommentSubmit = useCallback((commentText: string) => {
    if (propHandleMainCommentSubmitCallback) {
      propHandleMainCommentSubmitCallback(commentText);
    }
  }, [propHandleMainCommentSubmitCallback]);
  
  // Handle reply submission
  const handleReply = useCallback((commentId: string, replyText: string) => {
    if (propHandleReplySubmit) {
      propHandleReplySubmit(commentId, replyText);
    }
    setReplyingToCommentId(null);
    setCurrentReplyText('');
  }, [propHandleReplySubmit]);
  
  // Handle edit save
  const handleEdit = useCallback((commentId: string, newText: string) => {
    if (propHandleEditSave) {
      propHandleEditSave(commentId, newText);
    }
    setEditingComment(null);
  }, [propHandleEditSave]);
  
  // Handle delete comment
  const handleDelete = useCallback((commentId: string) => {
    if (propHandleDeleteComment) {
      propHandleDeleteComment(commentId);
    }
  }, [propHandleDeleteComment]);
  
  // Toggle like/dislike for comment or reply
  const toggleLikeDislike = useCallback((commentId: string, action: 'like' | 'dislike') => {
    if (propToggleLikeDislikeForCommentOrReply) {
      propToggleLikeDislikeForCommentOrReply(commentId, action);
    }
  }, [propToggleLikeDislikeForCommentOrReply]);
  
  // Toggle description expansion
  const toggleDescription = useCallback(() => {
    setIsDescriptionExpanded(prev => !prev);
    if (propHandleToggleDescription) {
      propHandleToggleDescription();
    }
  }, [propHandleToggleDescription]);
  
  // Handle summarize description
  const handleSummarize = useCallback(async () => {
    if (!video?.id || !propHandleSummarizeDescription) return;
    
    try {
      setIsSummarizing(true);
      const result = await propHandleSummarizeDescription(video.id);
      setSummary(result);
    } catch (error) {
      console.error('Error summarizing description:', error);
      // Handle error appropriately
    } finally {
      setIsSummarizing(false);
    }
  }, [video?.id, propHandleSummarizeDescription]);
  
  // Handler functions with fallbacks to props or default implementations
  const handleLike = useCallback((videoId: string) => {
    if (propHandleLike) {
      propHandleLike(videoId);
    }
  }, [propHandleLike]);
  
  const handleSubscribe = useCallback((channelId: string) => {
    if (propHandleSubscribe) {
      propHandleSubscribe(channelId);
    }
  }, [propHandleSubscribe]);
  
  // ... other handler functions with similar patterns ...
  
  const closeSaveModal = useCallback(() => {
    setIsSaveModalOpen(false);
    if (propCloseSaveModal) {
      propCloseSaveModal();
    }
  }, [propCloseSaveModal]);
  
  // Handle add to watch later
  const { addToWatchLater } = useWatchLater();
  const handleAddToWatchLater = useCallback(async () => {
    if (!video?.id) return;
    
    try {
      const videoToAdd: Video = {
        id: video.id,
        title: video.title || 'Untitled Video',
        description: video.description || '',
        duration: video.duration || '0:00',
        thumbnailUrl: video.thumbnailUrl || '',
        videoUrl: video.videoUrl || '',
        viewCount: video.viewCount || 0,
        channelName: video.channelName || 'Unknown Channel',
        channelAvatarUrl: video.channelAvatarUrl || '',
        uploadedAt: video.uploadedAt || new Date().toISOString(),
        ...video
      };
      
      if (propHandleAddToWatchLater) {
        await propHandleAddToWatchLater(videoToAdd);
      } else if (addToWatchLater) {
        await addToWatchLater(videoToAdd);
      }
    } catch (err) {
      console.error('Error adding to watch later:', err);
    }
  }, [video, propHandleAddToWatchLater, addToWatchLater]);
  const [activeCommentMenu, setActiveCommentMenu] = useState<string | null>(null);
  const [expandedReplies, setExpandedReplies] = useState<Record<string, boolean>>({});
  const [replyingToCommentId, setReplyingToCommentId] = useState<string | null>(null);
  const [currentReplyText, setCurrentReplyText] = useState('');
  const [editingComment, setEditingComment] = useState<{ id: string; text: string } | null>(null);
  const [actionError, setActionError] = useState<Error | null>(null);
  const [summary, setSummary] = useState<string | null>(null);
  const [summaryError, setSummaryError] = useState<Error | null>(null);
  const [isSummarizing, setIsSummarizing] = useState(false);
  const { videoId = '' } = useParams<{ videoId: string }>();
  const {
    video = mockVideo,
  const [isSaveModalOpen, setIsSaveModalOpen] = useState(saveModalOpen || false);
  const [commentSortOrder, setCommentSortOrder] = useState<'top' | 'newest'>('top');
  const [isDescriptionExpanded, setIsDescriptionExpanded] = useState(false);
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [summary, setSummary] = useState<string | null>(null);
  const [replyingToCommentId, setReplyingToCommentId] = useState<string | null>(null);
  const [currentReplyText, setCurrentReplyText] = useState('');
  const [editingComment, setEditingComment] = useState<{ id: string; text: string } | null>(null);
  const [activeCommentMenu, setActiveCommentMenu] = useState<string | null>(null);
  const [expandedReplies, setExpandedReplies] = useState<Record<string, boolean>>({});
  const [actionError, setActionError] = useState<string | null>(null);
  const [summaryError, setSummaryError] = useState<Error | null>(null);

  // Handle add to watch later
  const handleAddToWatchLater = useCallback(() => {
    if (!video) return;

    const videoToAdd: Video = {
      ...video,
      id: video.id || '',
      title: video.title || 'Untitled',
      description: video.description || '',
      views: video.views || '0',
      uploadedAt: video.uploadedAt || new Date().toISOString(),
      thumbnailUrl: video.thumbnailUrl || '',
      videoUrl: video.videoUrl || '',
      channelId: video.channelId || '',
      channelName: video.channelName || '',
      channelAvatarUrl: video.channelAvatarUrl || '',
      duration: video.duration || '0:00',
      likes: video.likes || 0,
      dislikes: video.dislikes || 0,
      tags: video.tags || [],
      visibility: video.visibility || 'public',
      commentCount: video.commentCount || 0,
      viewCount: video.viewCount || 0,
      category: video.category || 'Education',
      createdAt: video.createdAt || new Date().toISOString(),
      updatedAt: video.updatedAt || new Date().toISOString(),
      status: video.status || 'published',
    };

    if (video.id) {
      addToWatchLater(videoToAdd);
    }
  }, [video, addToWatchLater]);

  // Enhanced save to playlist handler that integrates with Watch Later context
  const enhancedHandleSaveToPlaylist = useCallback(async (playlistId: string) => {
    try {
      // Call the original handler if it exists
      if (handleSaveToPlaylist) {
        await handleSaveToPlaylist(playlistId);
      }

      // If saving to Watch Later, also add to Watch Later context
      if (playlistId === 'playlist-1' && video) {
        const now = new Date().toISOString();
        const coreVideo: Video = {
          ...video,
          id: video.id,
          title: video.title || 'Untitled Video',
          description: video.description || '',
          views: video.views || '0',
          uploadedAt: video.uploadedAt || now,
          thumbnailUrl: video.thumbnailUrl || '',
          videoUrl: video.videoUrl || '',
          channelId: video.channelId || 'unknown-channel',
          channelName: video.channelName || 'Unknown Channel',
          channelAvatarUrl: video.channelAvatarUrl || '',
          duration: video.duration || '0:00',
          category: video.category || 'Other',
          likes: 0,
          dislikes: 0,
          tags: [],
          visibility: 'public',
          commentCount: 0,
          viewCount: 0,
          createdAt: now,
          updatedAt: now,
          status: 'published',
        };

        if (addToWatchLater) {
          await addToWatchLater(coreVideo);
        }
      }
    } catch (error) {
      console.error('Error saving to playlist:', error);
    }
  }, [video, handleSaveToPlaylist, addToWatchLater]);

  // Handle watch later
  const handleAddToWatchLater = useCallback(async () => {
    if (!video) return;

    const videoToAdd: Video = {
      ...video,
      id: video.id,
      title: video.title,
      description: video.description || '',
      views: video.views || '0',
      uploadedAt: video.uploadedAt || new Date().toISOString(),
      thumbnailUrl: video.thumbnailUrl || '',
      videoUrl: video.videoUrl || '',
      channelId: video.channelId || '',
      channelName: video.channelName || 'Unknown Channel',
      channelAvatarUrl: video.channelAvatarUrl || '',
      duration: video.duration || '0:00',
      category: video.category || 'Other',
      likes: 0,
      dislikes: 0,
      tags: [],
      visibility: 'public',
      createdAt: video.createdAt || new Date().toISOString(),
      updatedAt: video.updatedAt || new Date().toISOString(),
    };

    await addToWatchLater(videoToAdd);
  }, [video, addToWatchLater]);

  // Handle save to playlist
  const handleSaveToPlaylist = useCallback(async (playlistId: string) => {
    try {
      // Implementation for saving to playlist
      console.log(`Saving video to playlist: ${playlistId}`);
      // Close the modal if it exists
      if (closeSaveModal) {
        closeSaveModal();
      }
    } catch (error) {
      console.error('Error saving to playlist:', error);
    }
  }, [closeSaveModal]);

  // Handle miniplayer
  const handleMiniplayer = useCallback(() => {
    if (!video) return;

    const now = new Date().toISOString();
    const videoForMiniplayer: Video = {
      ...video,
      id: video.id,
      title: video.title || 'Untitled Video',
      description: video.description || '',
      views: video.views || '0',
      uploadedAt: video.uploadedAt || now,
      thumbnailUrl: video.thumbnailUrl || '',
      videoUrl: video.videoUrl || '',
      channelId: video.channelId || 'unknown-channel',
      channelName: video.channelName || 'Unknown Channel',
      channelAvatarUrl: video.channelAvatarUrl || '',
      duration: video.duration || '0:00',
      category: video.category || 'Other',
      likes: 0,
      dislikes: 0,
      tags: [],
      visibility: 'public',
      commentCount: 0,
      viewCount: 0,
      createdAt: now,
      updatedAt: now,
      status: 'published',
    };

    // Show miniplayer if the function exists
    if (showMiniplayer) {
      showMiniplayer(videoForMiniplayer);
    }
  }, [video, showMiniplayer]);

  // Enhanced action handlers with error handling
  const handleEnhancedLike = useCallback(() => {
    try {
      handleLike();
    } catch (err) {
      console.error('Error liking video:', err);
      setActionError(err as Error);
    }
  }, [handleLike]);

  const handleEnhancedSubscribe = useCallback(() => {
    try {
      handleSubscribe();
    } catch (err) {
      console.error('Error subscribing to channel:', err);
      setActionError(err as Error);
    }
  }, [handleSubscribe]);

  const handleEnhancedShare = useCallback(() => {
    try {
      handleShare();
    } catch (err) {
      console.error('Error sharing video:', err);
      setActionError(err as Error);
    }
  }, [handleShare]);

  const handleEnhancedDislike = useCallback(() => {
    try {
      handleDislike();
    } catch (err) {
      console.error('Error disliking video:', err);
      setActionError(err as Error);
    }
  }, [handleDislike]);

  // Video player configuration
  const videoPlayerProps = video
    ? {
        video: {
          ...video,
          captions: video.captions || [],
          duration: video.duration || '0:00',
          thumbnailUrl: video.thumbnailUrl || '',
          videoUrl: video.videoUrl || '',
        },
        autoPlay: true,
        showControls: true,
        loop: false,
        muted: false,
        volume: 1,
        playbackRate: 1,
        isTheaterMode: false,
        isMiniPlayer: false,
        isFullscreen: false,
        showCaptions: true,
        captions: video?.captions?.map((caption) => ({
          id: caption.id,
          language: {
            code: caption.language.code,
            name: caption.language.name,
          },
          label: caption.label,
          url: caption.url,
          isAutoGenerated: caption.isAutoGenerated || false,
        })) || [],
        currentCaption: null,
        onCaptionChange: () => {},
        onPlaybackRateChange: () => {},
        onVolumeChange: () => {},
        onToggleMute: () => {},
        onToggleTheaterMode: () => {},
        onToggleMiniPlayer: () => {},
        onToggleFullscreen: () => {},
        onTimeUpdate: (currentTime: number) => {
          // Handle time update
        },
        onEnded: () => {
          // Handle video end
        },
        onError: (error: string) => {
          console.error('Video player error:', error);
          setActionError(new Error(error));
        },
      }
    : null;

  // Video actions configuration
  const videoActionsProps = {
    liked,
    disliked,
    isSubscribed,
    isSavedToAnyList,
    likeCount: video?.likes || 0,
    dislikeCount: video?.dislikes || 0,
    commentCount: video?.commentCount || 0,
    viewCount: video?.viewCount || 0,
    onLike: handleEnhancedLike,
    onDislike: handleEnhancedDislike,
    onSubscribe: handleEnhancedSubscribe,
    onShare: handleEnhancedShare,
    onSave: () => setIsSaveModalOpen(true),
    onAddToWatchLater: handleAddToWatchLater,
    onComment: () => {
      // Handle comment action
    },
    onMore: () => {
      // Handle more options
    },
  };

  // Handle summarize description
  const handleSummarize = useCallback(async () => {
    if (!video?.description) return;

    setIsSummarizing(true);
    setSummaryError(null);

    try {
      const result = await handleSummarizeDescription();
      setSummary(result);
    } catch (err) {
      console.error('Error summarizing description:', err);
      setSummaryError(err as Error);
    } finally {
      setIsSummarizing(false);
    }
  }, [video?.description, handleSummarizeDescription]);

  // Video description configuration
  const videoDescriptionProps = {
    video: video!,
    channel: channel!,
    showFullDescription,
    summary: summary || undefined,
    summaryError: summaryError?.message,
    isSummarizing,
    onToggleDescription: handleToggleDescription,
    onSummarize: handleSummarize,
    onSubscribe: handleEnhancedSubscribe,
    isSubscribed,
  };

  // Comments section configuration
  const commentsSectionProps = {
    comments: comments || [],
    sortOrder: commentSortOrder,
    onSortChange: setCommentSortOrder,
    onCommentSubmit: handleMainCommentSubmitCallback,
    onReplySubmit: handleReplySubmit,
    onEditSave: handleEditSave,
    onDelete: handleDeleteComment,
    onLike: toggleLikeDislikeForCommentOrReply,
    onDislike: toggleLikeDislikeForCommentOrReply,
    replyingToCommentId: replyingToCommentId || undefined,
    onSetReplyingToCommentId: setReplyingToCommentId as (id: string | null) => void,
    currentReplyText: currentReplyText || '',
    onCurrentReplyTextChange: setCurrentReplyText,
    editingComment: editingComment || undefined,
    onSetEditingComment: setEditingComment as (comment: { id: string; text: string } | null) => void,
    activeCommentMenu: activeCommentMenu || undefined,
    onSetActiveCommentMenu: setActiveCommentMenu as (id: string | null) => void,
    expandedReplies,
    onToggleReplies: (commentId: string) => {
      setExpandedReplies(prev => ({
        ...prev,
        [commentId]: !prev[commentId]
      }));
    },
    currentUser: {
      id: 'current-user-id',
      name: 'Current User',
      avatarUrl: ''
      isFullscreen: false,
      showCaptions: true,
      captions: video?.captions?.map((caption) => ({
        id: caption.id,
        language: {
          code: caption.language.code,
          name: caption.language.name,
        },
        label: caption.label,
        url: caption.url,
        isAutoGenerated: caption.isAutoGenerated || false,
      })) || [],
      currentCaption: null,
      onCaptionChange: () => {},
      onPlaybackRateChange: () => {},
      onVolumeChange: () => {},
      onToggleMute: () => {},
      onToggleTheaterMode: () => {},
      onToggleMiniPlayer: () => {},
      onToggleFullscreen: () => {},
      onTimeUpdate: (currentTime: number) => {
        // Handle time update
      },
      onEnded: () => {
        // Handle video end
      },
      onError: (error: string) => {
        console.error('Video player error:', error);
        setActionError(new Error(error));
      },
    }
  : null;

// Video actions configuration
const videoActionsProps = {
  liked,
  disliked,
  isSubscribed,
  isSavedToAnyList,
  likeCount: video?.likes || 0,
  dislikeCount: video?.dislikes || 0,
  commentCount: video?.commentCount || 0,
  viewCount: video?.viewCount || 0,
  onLike: handleEnhancedLike,
  onDislike: handleEnhancedDislike,
  onSubscribe: handleEnhancedSubscribe,
  onShare: handleEnhancedShare,
  onSave: () => setIsSaveModalOpen(true),
  onAddToWatchLater: handleAddToWatchLater,
  onComment: () => {
    // Handle comment action
  },
  onMore: () => {
    // Handle more options
  },
};

// Handle summarize description
const handleSummarize = useCallback(async () => {
  if (!video?.description) return;

  setIsSummarizing(true);
  setSummaryError(null);

  try {
    const result = await handleSummarizeDescription();
    setSummary(result);
  } catch (err) {
    console.error('Error summarizing description:', err);
    setSummaryError(err as Error);
  } finally {
    setIsSummarizing(false);
  }
}, [video?.description, handleSummarizeDescription]);

// Video description configuration
const videoDescriptionProps = {
  video: video!,
  channel: channel!,
  showFullDescription,
  summary: summary || undefined,
  summaryError: summaryError?.message,
  isSummarizing,
  onToggleDescription: handleToggleDescription,
  onSummarize: handleSummarize,
  onSubscribe: handleEnhancedSubscribe,
  isSubscribed,
};

// Comments section configuration
  // Prepare comments section props
  const commentsSectionProps = {
    comments: [], // Initialize with empty array or actual comments data
    sortOrder: commentSortOrder,
    onSortChange: (order: 'top' | 'newest') => setCommentSortOrder(order),
    onCommentSubmit: (commentText: string) => {
      if (propHandleMainCommentSubmitCallback) {
        propHandleMainCommentSubmitCallback(commentText);
      }
    },
    onReplySubmit: (commentId: string, replyText: string) => {
      if (propHandleReplySubmit) {
        propHandleReplySubmit(commentId, replyText);
      }
    },
    onEditSave: (commentId: string, newText: string) => {
      if (propHandleEditSave) {
        propHandleEditSave(commentId, newText);
      }
    },
    onDelete: (commentId: string) => {
      if (propHandleDeleteComment) {
        propHandleDeleteComment(commentId);
      }
    },
    onLike: (commentId: string) => {
      if (propToggleLikeDislikeForCommentOrReply) {
        propToggleLikeDislikeForCommentOrReply(commentId, 'like');
      }
    },
    onDislike: (commentId: string) => {
      if (propToggleLikeDislikeForCommentOrReply) {
        propToggleLikeDislikeForCommentOrReply(commentId, 'dislike');
      }
    },
    replyingToCommentId: replyingToCommentId || undefined,
    onSetReplyingToCommentId: (id: string | null) => setReplyingToCommentId(id),
    currentReplyText: currentReplyText || '',
    onCurrentReplyTextChange: (text: string) => setCurrentReplyText(text),
    editingComment: editingComment || undefined,
    onSetEditingComment: (comment: { id: string; text: string } | null) => setEditingComment(comment),
    activeCommentMenu: activeCommentMenu || undefined,
    onSetActiveCommentMenu: (id: string | null) => setActiveCommentMenu(id),
    expandedReplies: expandedReplies || [],
    onToggleReplies: (commentId: string) => {
      setExpandedReplies(prev => 
        prev.includes(commentId)
          ? prev.filter(id => id !== commentId)
          : [...prev, commentId]
      );
    },
    currentUser: {
      id: 'current-user-id',
      name: 'Current User',
      avatarUrl: ''
    }
  };

  // Video player props
  const videoPlayerProps = {
    src: video?.videoUrl || '',
    poster: video?.thumbnailUrl || '',
    title: video?.title || '',
    duration: video?.duration || '0:00',
    isPlaying: true,
    isMuted: false,
    volume: 1,
    playbackRate: 1,
    currentTime: 0,
    isFullscreen: false,
    isTheaterMode: false,
    isMiniPlayer: false,
    showControls: true,
    onPlay: () => {},
    onPause: () => {},
    onSeek: () => {},
    onEnded: () => {},
    onError: (error: string) => {
      console.error('Video error:', error);
      setActionError('Error playing video');
    },
    onCaptionChange: () => {},
    onPlaybackRateChange: () => {},
    onVolumeChange: () => {},
    onToggleMute: () => {},
    onToggleTheaterMode: () => {},
    onToggleMiniPlayer: () => {},
    onToggleFullscreen: () => {},
    onTimeUpdate: () => {}
  };

  // Video actions props
  const videoActionsProps = {
    likes: video?.likes || 0,
    dislikes: video?.dislikes || 0,
    isLiked: video?.isLiked || false,
    isDisliked: video?.isDisliked || false,
    isSubscribed: video?.isSubscribed || false,
    isSaved: video?.isSavedToAnyList || false,
    onLike: () => propHandleLike(video?.id || ''),
    onDislike: () => propHandleDislike(video?.id || ''),
    onSubscribe: () => propHandleSubscribe(video?.channelId || ''),
    onShare: () => propHandleShare(video?.id || ''),
    onSave: () => setIsSaveModalOpen(true),
    onAddToWatchLater: handleAddToWatchLater,
    onComment: () => {
      const commentsSection = document.getElementById('comments-section');
      if (commentsSection) {
        commentsSection.scrollIntoView({ behavior: 'smooth' });
      }
    },
    onMore: () => {}
  };

  // Video description props
  const videoDescriptionProps = {
    title: video?.title || '',
    viewCount: video?.viewCount || 0,
    uploadedAt: video?.uploadedAt || new Date().toISOString(),
    description: video?.description || '',
    channel: video?.channel || {
      id: video?.channelId || '',
      name: video?.channelName || 'Unknown Channel',
      avatarUrl: video?.channelAvatarUrl || '',
      isSubscribed: video?.isSubscribed || false
    },
    showFullDescription: isDescriptionExpanded,
    onToggleDescription: () => {
      setIsDescriptionExpanded(!isDescriptionExpanded);
      propHandleToggleDescription();
    },
    summary: summary || '',
    isSummarizing,
    onSummarize: handleSummarize,
    summaryError: summaryError?.message || null,
    onSubscribe: () => propHandleSubscribe(video?.channelId || ''),
    isSubscribed: video?.isSubscribed || false
  };

  // Save to playlist modal props
  const saveToPlaylistModalProps = {
    isOpen: isSaveModalOpen,
    onClose: () => {
      setIsSaveModalOpen(false);
      propCloseSaveModal();
    },
    onSave: handleSaveToPlaylist,
    playlists: [], // Empty array as we don't have mock playlists
    selectedPlaylistId: '',
    onSelectPlaylist: () => {},
    onCreatePlaylist: handleCreatePlaylist,
    videoId: video?.id || ''
  };

  if (loading) {
    return (
      <StandardPageLayout>
        <div className="flex justify-center items-center h-64">
          <p>Loading video...</p>
        </div>
      </StandardPageLayout>
    );
  }
  
  if (error) {
    return (
      <StandardPageLayout>
        <div className="p-4 text-red-600 dark:text-red-400">
          {error}
        </div>
      </StandardPageLayout>
    );
  }
  
  if (!video) {
    return (
      <StandardPageLayout>
        <div className="p-4">
          <p>Video not found</p>
        </div>
      </StandardPageLayout>
    );
  }
  
  return (
    <StandardPageLayout>
      <div className="flex flex-col lg:flex-row gap-6">
        {/* Main content */}
        <div className="flex-1">
          {/* Video player */}
          <div className="mb-6">
            <RefactoredVideoPlayer {...videoPlayerProps} />
          </div>
          
          {/* Video info */}
          <div className="mb-6">
            <h1 className="text-2xl font-bold mb-2">{video.title}</h1>
            <div className="flex items-center text-sm text-gray-600 dark:text-gray-400 mb-4">
              <span>{video.viewCount} views</span>
              <span className="mx-2">•</span>
              <span>{new Date(video.uploadedAt || '').toLocaleDateString()}</span>
            </div>
          </div>
          
          {/* Video actions */}
          <div className="mb-6">
            <VideoActions {...videoActionsProps} />
          </div>
          
          {/* Video description */}
          <div className="mb-6">
            <RefactoredVideoDescription {...videoDescriptionProps} />
          </div>
          
          {/* Comments section */}
          <div id="comments-section" className="mb-6">
            <CommentsSection {...commentsSectionProps} />
          </div>
        </div>
        
        {/* Sidebar - Recommendations */}
        <div className="w-full lg:w-80 flex-shrink-0">
          <RecommendationEngine
            currentVideoId={video.id}
            onVideoSelect={(videoId: string) => {
              // Handle video selection
              console.log('Selected video:', videoId);
            }}
          />
        </div>
      </div>
      
      {/* Save to playlist modal */}
      <RefactoredSaveToPlaylistModal {...saveToPlaylistModalProps} />
      
      {/* Error message */}
      {actionError && (
        <div className="fixed bottom-4 right-4 p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg shadow-lg">
          <p className="text-red-600 dark:text-red-400">{actionError}</p>
        </div>
      )}
    </StandardPageLayout>
  );
};

export default RefactoredWatchPage;